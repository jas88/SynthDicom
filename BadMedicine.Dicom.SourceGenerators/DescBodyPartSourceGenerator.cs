using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace BadMedicine.Dicom.SourceGenerators;

[Generator]
public sealed class DescBodyPartSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var descBodyPartFile = context.AdditionalTextsProvider.Where(static file => file.Path.EndsWith("DicomDataGeneratorDescBodyPart.csv", StringComparison.OrdinalIgnoreCase)).Select(static (file, cancellationToken) => file.GetText(cancellationToken)?.ToString() ?? string.Empty);
        context.RegisterSourceOutput(descBodyPartFile, (ctx, csvContent) => { try { if (!string.IsNullOrEmpty(csvContent)) { var sourceCode = GenerateDescBodyPartClass(csvContent); ctx.AddSource("DescBodyPartData.g.cs", SourceText.From(sourceCode, Encoding.UTF8)); } } catch (Exception ex) { ctx.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("DICOM001", "DescBodyPart Generation Error", $"Error generating source for DescBodyPart: {ex.Message}", "BadMedicine.Dicom.SourceGenerators", DiagnosticSeverity.Warning, isEnabledByDefault: true), Location.None)); } });
    }

    private static string GenerateDescBodyPartClass(string csvContent)
    {
        var lines = csvContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        if (lines.Length < 2) return string.Empty;
        var modalityGroups = new Dictionary<string, List<(int count, string studyDesc, string bodyPart, string seriesDesc)>>();
        for (int i = 1; i < lines.Length; i++) { var parts = ParseCsvLine(lines[i]); if (parts.Length != 5) continue; var modality = parts[0]; var studyDesc = parts[1]; var bodyPart = parts[2]; var seriesDesc = parts[3]; if (!int.TryParse(parts[4], out var count)) continue; if (!modalityGroups.ContainsKey(modality)) modalityGroups[modality] = new List<(int, string, string, string)>(); modalityGroups[modality].Add((count, studyDesc, bodyPart, seriesDesc)); }
        var code = new StringBuilder();
        code.AppendLine("// <auto-generated />");
        code.AppendLine("#nullable enable");
        code.AppendLine();
        code.AppendLine("using System.Collections.Generic;");
        code.AppendLine("using System.Collections.ObjectModel;");
        code.AppendLine("using SynthEHR;");
        code.AppendLine();
        code.AppendLine("namespace BadMedicine.Dicom;");
        code.AppendLine();
        code.AppendLine("/// <summary>");
        code.AppendLine("/// Generated data for DescBodyPart from DicomDataGeneratorDescBodyPart.csv");
        code.AppendLine("/// </summary>");
        code.AppendLine("[global::System.CodeDom.Compiler.GeneratedCode(\"BadMedicine.Dicom.SourceGenerators.DescBodyPartSourceGenerator\", \"1.0.0\")]");
        code.AppendLine("[global::System.Runtime.CompilerServices.CompilerGenerated]");
        code.AppendLine("internal static class DescBodyPartData");
        code.AppendLine("{");
        code.AppendLine("    internal static readonly ReadOnlyDictionary<string, BucketList<DescBodyPart>> Data =");
        code.AppendLine("        new Dictionary<string, BucketList<DescBodyPart>>");
        code.AppendLine("        {");
        bool firstModality = true;
        foreach (var modality in modalityGroups.Keys.OrderBy(k => k)) { if (!firstModality) code.AppendLine(","); firstModality = false; code.AppendLine("            {"); code.AppendLine($"                \"{EscapeString(modality)}\","); code.AppendLine("                new BucketList<DescBodyPart>"); code.AppendLine("                {"); var entries = modalityGroups[modality]; for (int i = 0; i < entries.Count; i++) { var (count, studyDesc, bodyPart, seriesDesc) = entries[i]; var comma = i < entries.Count - 1 ? "," : ""; code.AppendLine($"                    {{{count},new DescBodyPart({FormatStringLiteral(studyDesc)},{FormatStringLiteral(bodyPart)},{FormatStringLiteral(seriesDesc)})}}{comma}"); } code.AppendLine("                }"); code.Append("            }"); }
        code.AppendLine();
        code.AppendLine("        }.AsReadOnly();");
        code.AppendLine("}");
        return code.ToString();
    }

    private static string[] ParseCsvLine(string line) { var fields = new List<string>(); var currentField = new StringBuilder(); bool inQuotes = false; for (int i = 0; i < line.Length; i++) { char c = line[i]; if (c == '"') { if (inQuotes && i + 1 < line.Length && line[i + 1] == '"') { currentField.Append('"'); i++; } else { inQuotes = !inQuotes; } } else if (c == ',' && !inQuotes) { fields.Add(currentField.ToString()); currentField.Clear(); } else { currentField.Append(c); } } fields.Add(currentField.ToString()); return fields.ToArray(); }
    private static string FormatStringLiteral(string value) { if (string.IsNullOrEmpty(value)) return "\"\""; if (value.Contains("\"") || value.Contains("\\") || value.Contains("\n")) { return $"\"\"\"{EscapeString(value)}\"\"\""; } return $"\"{EscapeString(value)}\""; }
    private static string EscapeString(string value) { return value.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "\\r").Replace("\t", "\\t"); }
}
